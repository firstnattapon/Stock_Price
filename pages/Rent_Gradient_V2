
# import streamlit as st
# import folium
# from streamlit_folium import st_folium
# import requests
# from shapely.geometry import shape, mapping
# from shapely.ops import unary_union
# from shapely import wkt
# import json
# import networkx as nx
# import osmnx as ox
# import matplotlib.cm as cm
# import matplotlib.colors as colors
# from typing import List, Dict, Any, Optional, Tuple
# import time
# import hashlib
# import pickle
# import os
# from pathlib import Path
# import zipfile
# import io
# from math import radians, sin, cos, sqrt, atan2
# import random

# # ============================================================================
# # 1. CONSTANTS & CONFIGURATION (Unified)
# # ============================================================================

# PAGE_CONFIG = {
#     "page_title": "Geoapify CBD x Longdo GIS + Network Analysis (Pro)",
#     "page_icon": "üåç",
#     "layout": "wide"
# }

# # Centralized Configuration
# APP_CONFIG = {
#     "JSON_URL": "https://raw.githubusercontent.com/firstnattapon/Stock_Price/refs/heads/main/Geoapify_Map/geoapify_cbd_project.json",
#     "DEFAULT": {
#         "LAT": 20.219443,
#         "LON": 100.403630,
#         "GEOAPIFY_KEY": "4eefdfb0b0d349e595595b9c03a69e3d",
#         "LONGDO_KEY": "0a999afb0da60c5c45d010e9c171ffc8",
#     },
#     "CACHE_DIR": Path("./cache"),
#     "GITHUB": {
#         "API_URL": "https://api.github.com/repos/firstnattapon/Stock_Price/contents/Geoapify_Map",
#         "RAW_BASE": "https://raw.githubusercontent.com/firstnattapon/Stock_Price/main/Geoapify_Map"
#     },
#     "NETWORK": {
#         'min_closeness_threshold': 0.0,
#         'edge_weight_base': 2,
#         'edge_weight_multiplier': 4,
#         'cache_ttl_seconds': 3600,
#         'click_debounce_seconds': 0.5,
#         'click_distance_threshold_meters': 10,
#         'large_graph_threshold': 1500,  # Lowered threshold for responsiveness
#         'sample_size_k': 200,          # For approximate betweenness
#         'timeout': 30
#     },
#     "VISUAL": {
#         "MARKER_COLORS": ['red', 'blue', 'green', 'purple', 'orange', 'black', 'pink', 'cadetblue'],
#         "HEX_COLORS": ['#D63E2A', '#38AADD', '#72B026', '#D252B9', '#F69730', '#333333', '#FF91EA', '#436978'],
#         "MAP_STYLES": {
#             "Esri Light Gray (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏ú‡∏±‡∏á‡πÄ‡∏°‡∏∑‡∏≠‡∏á)": {
#                 "tiles": "https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}",
#                 "attr": "Tiles &copy; Esri"
#             },
#             "Google Maps (‡∏ú‡∏™‡∏°/Hybrid)": {
#                 "tiles": "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", 
#                 "attr": "Google Maps"
#             },
#             "OpenStreetMap (‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô)": {"tiles": "OpenStreetMap", "attr": None},
#             "Esri Satellite (‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡∏ä‡∏±‡∏î)": {
#                 "tiles": "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
#                 "attr": "Tiles &copy; Esri"
#             }
#         },
#         "TRAVEL_MODES": {
#             "drive": "üöó ‡∏Ç‡∏±‡∏ö‡∏£‡∏ñ",
#             "walk": "üö∂ ‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏ó‡πâ‡∏≤",
#             "bicycle": "üö≤ ‡∏õ‡∏±‡πà‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô",
#             "transit": "üöå ‡∏Ç‡∏ô‡∏™‡πà‡∏á‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞"
#         }
#     }
# }

# APP_CONFIG["CACHE_DIR"].mkdir(exist_ok=True)
# LONGDO_WMS_URL = f"https://ms.longdo.com/mapproxy/service?key={APP_CONFIG['DEFAULT']['LONGDO_KEY']}"

# # Keys to persist in config file
# SESSION_KEYS_TO_SAVE = [
#     'api_key', 'map_style_name', 'travel_mode', 'time_intervals', 
#     'show_dol', 'show_cityplan', 'cityplan_opacity', 'show_population', 
#     'show_traffic', 'colors', 'show_betweenness', 'show_closeness'
# ]

# # ============================================================================
# # 2. UTILITY FUNCTIONS (Pure Logic)
# # ============================================================================

# def get_fill_color(minutes: float, colors_config: Dict[str, str]) -> str:
#     """Determine polygon color based on travel time."""
#     if minutes <= 10: return colors_config['step1']
#     if minutes <= 20: return colors_config['step2']
#     if minutes <= 30: return colors_config['step3']
#     return colors_config['step4']

# def get_border_color(original_marker_idx: Optional[int]) -> str:
#     """Determine border color based on marker index to differentiate sources."""
#     if original_marker_idx is None: return '#3388ff'
#     hex_colors = APP_CONFIG["VISUAL"]["HEX_COLORS"]
#     return hex_colors[original_marker_idx % len(hex_colors)]

# def calculate_distance_meters(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
#     """Calculate approximate distance in meters using Haversine formula."""
#     R = 6371000  # Earth radius in meters
#     lat1_rad, lon1_rad = radians(lat1), radians(lon1)
#     lat2_rad, lon2_rad = radians(lat2), radians(lon2)
#     dlat = lat2_rad - lat1_rad
#     dlon = lon2_rad - lon1_rad
#     a = sin(dlat/2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon/2)**2
#     c = 2 * atan2(sqrt(a), sqrt(1-a))
#     return R * c

# def should_add_marker(new_lat: float, new_lon: float) -> bool:
#     """Robust debouncing logic to prevent duplicate markers."""
#     last_click = st.session_state.get('last_processed_click')
#     if last_click is None: return True
    
#     if (time.time() - last_click['timestamp']) < APP_CONFIG['NETWORK']['click_debounce_seconds']:
#         return False
        
#     distance = calculate_distance_meters(last_click['lat'], last_click['lon'], new_lat, new_lon)
#     return distance >= APP_CONFIG['NETWORK']['click_distance_threshold_meters']

# def calculate_intersection(features: List[Dict], num_active_markers: int) -> Optional[Dict]:
#     """Calculate the geometric intersection (CBD) of isochrones."""
#     if num_active_markers < 2: return None
    
#     polys_per_active_idx = {}
#     for feat in features:
#         active_idx = feat['properties']['active_index']
#         geom = shape(feat['geometry'])
#         polys_per_active_idx[active_idx] = polys_per_active_idx.get(active_idx, geom).union(geom)
    
#     if len(polys_per_active_idx) < num_active_markers: return None
    
#     try:
#         active_indices = sorted(polys_per_active_idx.keys())
#         intersection_poly = polys_per_active_idx[active_indices[0]]
#         for idx in active_indices[1:]:
#             intersection_poly = intersection_poly.intersection(polys_per_active_idx[idx])
#             if intersection_poly.is_empty: return None
#         return mapping(intersection_poly) if not intersection_poly.is_empty else None
#     except Exception:
#         return None

# # ============================================================================
# # 3. API & ALGORITHMS (Heavy Lifting)
# # ============================================================================

# def safe_fetch_isochrone(api_key: str, travel_mode: str, ranges_str: str, 
#                          marker_lat: float, marker_lon: float) -> Tuple[Optional[List[Dict]], Optional[str]]:
#     """Safely fetch isochrone data with proper error handling."""
#     url = "https://api.geoapify.com/v1/isoline"
#     params = {
#         "lat": marker_lat, "lon": marker_lon, 
#         "type": "time", "mode": travel_mode, 
#         "range": ranges_str, "apiKey": api_key
#     }
    
#     try:
#         response = requests.get(url, params=params, timeout=APP_CONFIG['NETWORK']['timeout'])
#         if response.status_code == 200:
#             data = response.json()
#             features = data.get('features')
#             return (features, None) if features else (None, "API response missing 'features' data")
            
#         status_map = {
#             401: "‚ùå Invalid API Key - Please check your Geoapify API key",
#             403: "‚ùå API Key Forbidden - Check your account permissions",
#             429: "‚ö†Ô∏è Rate Limit Exceeded - Please wait before retrying"
#         }
#         return None, status_map.get(response.status_code, f"API Error (Status {response.status_code})")
            
#     except requests.Timeout: return None, "‚è±Ô∏è Request Timeout"
#     except requests.ConnectionError: return None, "üåê Connection Error"
#     except Exception as e: return None, f"Unexpected Error: {str(e)}"

# @st.cache_data(show_spinner=False, ttl=APP_CONFIG['NETWORK']['cache_ttl_seconds'])
# def fetch_api_data_with_error(api_key: str, travel_mode: str, ranges_str: str, 
#                                marker_lat: float, marker_lon: float) -> Tuple[Optional[List[Dict]], Optional[str]]:
#     """Cached wrapper for API calls."""
#     return safe_fetch_isochrone(api_key, travel_mode, ranges_str, marker_lat, marker_lon)

# # --- Optimized Graph Caching ---

# def get_cache_key(polygon_wkt_str: str, network_type: str) -> str:
#     """Generate a stable cache key from polygon bounds."""
#     polygon = wkt.loads(polygon_wkt_str)
#     # Round bounds to ensure cache hits for visually identical areas
#     rounded_bounds = tuple(round(b, 3) for b in polygon.bounds)
#     return hashlib.md5(f"{rounded_bounds}_{network_type}".encode()).hexdigest()

# def get_graph_cache_path(cache_key: str) -> Path:
#     return APP_CONFIG["CACHE_DIR"] / f"osm_graph_{cache_key}.pkl"

# def load_graph_from_disk(cache_key: str) -> Optional[nx.MultiDiGraph]:
#     path = get_graph_cache_path(cache_key)
#     if path.exists():
#         try:
#             with open(path, 'rb') as f: return pickle.load(f)
#         except Exception: return None
#     return None

# def save_graph_to_disk(cache_key: str, graph: nx.MultiDiGraph):
#     try:
#         # Clean graph before pickling to reduce size/errors
#         G_clean = graph.copy()
#         with open(get_graph_cache_path(cache_key), 'wb') as f:
#             pickle.dump(G_clean, f, protocol=pickle.HIGHEST_PROTOCOL)
#     except Exception: pass

# # --- Optimized Centrality Algorithms ---

# def _fetch_osm_graph(polygon_wkt_str: str, network_type: str) -> Tuple[Optional[nx.MultiDiGraph], bool, Optional[str]]:
#     """Fetch OSM graph with robust caching and error handling."""
#     try:
#         cache_key = get_cache_key(polygon_wkt_str, network_type)
#         G = load_graph_from_disk(cache_key)
        
#         if G: return G, True, None
        
#         # Fresh fetch
#         polygon_geom = wkt.loads(polygon_wkt_str)
#         G = ox.graph_from_polygon(polygon_geom, network_type=network_type, truncate_by_edge=True)
        
#         if len(G.nodes) > 0:
#             save_graph_to_disk(cache_key, G)
#             return G, False, None
#         return None, False, "No OSM data found in this area."
        
#     except Exception as e:
#         return None, False, f"Graph Fetch Error: {str(e)}"

# @st.cache_data(show_spinner=False, ttl=APP_CONFIG['NETWORK']['cache_ttl_seconds'])
# def _compute_centrality_optimized(polygon_wkt_str: str, network_type: str) -> Dict[str, Any]:
#     """
#     Optimized Centrality Calculation:
#     - Uses 'k-shortest paths' approximation for Edge Betweenness on large graphs.
#     - Falls back to exact methods for small graphs.
#     """
#     G, was_cached, error = _fetch_osm_graph(polygon_wkt_str, network_type)
#     if error: return {"error": error}
    
#     node_count = len(G.nodes)
#     if node_count < 2: return {"error": "Not enough nodes (needs 2+)."}

#     # Optimization Thresholds
#     is_large = node_count > APP_CONFIG['NETWORK']['large_graph_threshold']
#     approx_k = APP_CONFIG['NETWORK']['sample_size_k'] if is_large else None

#     # 1. Closeness Centrality
#     # (Note: Approx closeness is complex to implement purely with NX without C extensions, 
#     # so we stick to exact for now unless graph is HUGE, or skip it. 
#     # For now, we use exact but on the undirected graph which is slightly faster)
#     closeness_cent = nx.closeness_centrality(G)
#     max_close = max(closeness_cent.values()) if closeness_cent else 1

#     # 2. Edge Betweenness Centrality (The Bottleneck)
#     G_undir = G.to_undirected()
#     if is_large:
#         # STOCHASTIC APPROXIMATION: Use k random nodes? No, NX supports 'k' for node betweenness.
#         # For edge_betweenness, NX api: edge_betweenness_centrality(G, k=None, normalized=True, weight=None, seed=None)
#         # We use k to limit source nodes.
#         betweenness_cent = nx.edge_betweenness_centrality(
#             G_undir, weight='length', 
#             k=approx_k, 
#             seed=42 # Stable seed for reproducible approximation
#         )
#     else:
#         betweenness_cent = nx.edge_betweenness_centrality(G_undir, weight='length')
        
#     max_bet = max(betweenness_cent.values()) if betweenness_cent else 1

#     # 3. Format Data for Folium
#     edges_geojson = []
#     cmap_bet = cm.get_cmap('plasma')
    
#     for u, v, k, data in G.edges(keys=True, data=True):
#         score = betweenness_cent.get(tuple(sorted((u, v))), 0)
#         norm_score = score / max_bet if max_bet > 0 else 0
        
#         geom = mapping(data['geometry']) if 'geometry' in data else {
#             "type": "LineString",
#             "coordinates": [[G.nodes[u]['x'], G.nodes[u]['y']], [G.nodes[v]['x'], G.nodes[v]['y']]]
#         }
        
#         edges_geojson.append({
#             "type": "Feature",
#             "geometry": geom,
#             "properties": {
#                 "betweenness": norm_score,
#                 "color": colors.to_hex(cmap_bet(norm_score)),
#                 "stroke_weight": APP_CONFIG['NETWORK']['edge_weight_base'] + (norm_score * APP_CONFIG['NETWORK']['edge_weight_multiplier'])
#             }
#         })
        
#     nodes_geojson = []
#     top_node = {"score": -1, "lat": 0, "lon": 0}
    
#     for node, data in G.nodes(data=True):
#         score = closeness_cent.get(node, 0)
#         norm_score = score / max_close if max_close > 0 else 0
        
#         if score > top_node["score"]:
#             top_node = {"lat": data['y'], "lon": data['x'], "score": score}
            
#         if norm_score > APP_CONFIG['NETWORK']['min_closeness_threshold']:
#             nodes_geojson.append({
#                 "type": "Feature",
#                 "geometry": {"type": "Point", "coordinates": [data['x'], data['y']]},
#                 "properties": {
#                     "closeness": norm_score,
#                     "color": "#000000",
#                     "radius": 2 + (norm_score * 6)
#                 }
#             })

#     return {
#         "edges": {"type": "FeatureCollection", "features": edges_geojson},
#         "nodes": {"type": "FeatureCollection", "features": nodes_geojson},
#         "top_node": top_node if top_node["score"] != -1 else None,
#         "stats": {
#             "nodes_count": node_count,
#             "edges_count": len(G.edges),
#             "approx": is_large,
#             "cached": was_cached
#         }
#     }

# # ============================================================================
# # 4. UI STATE & INTERACTION
# # ============================================================================

# def init_session_state():
#     defaults = {
#         'markers': [{'lat': APP_CONFIG['DEFAULT']['LAT'], 'lng': APP_CONFIG['DEFAULT']['LON'], 'active': True}],
#         'isochrone_data': None, 'intersection_data': None, 'network_data': None,
#         'colors': {'step1': '#2A9D8F', 'step2': '#E9C46A', 'step3': '#F4A261', 'step4': '#D62828'},
#         'api_key': APP_CONFIG['DEFAULT']['GEOAPIFY_KEY'],
#         'map_style_name': "Esri Light Gray (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏ú‡∏±‡∏á‡πÄ‡∏°‡∏∑‡∏≠‡∏á)",
#         'travel_mode': "drive", 'time_intervals': [5],
#         'show_dol': False, 'show_cityplan': False, 'cityplan_opacity': 0.7,
#         'show_population': False, 'show_traffic': False,
#         'show_betweenness': False, 'show_closeness': False,
#         'last_processed_click': None
#     }
    
#     # Load remote defaults if needed (Optional)
#     if 'markers' not in st.session_state:
#         try:
#             resp = requests.get(APP_CONFIG['JSON_URL'], timeout=2)
#             if resp.status_code == 200:
#                 remote_data = resp.json()
#                 defaults.update({k: v for k, v in remote_data.items() if k in defaults})
#         except: pass

#     for k, v in defaults.items():
#         st.session_state.setdefault(k, v)

# def clear_results(targets=['isochrone', 'intersection', 'network']):
#     for t in targets:
#         if t == 'isochrone': st.session_state.isochrone_data = None
#         elif t == 'intersection': st.session_state.intersection_data = None
#         elif t == 'network': st.session_state.network_data = None

# # ============================================================================
# # 5. UI COMPONENTS (Frontend)
# # ============================================================================

# def render_sidebar():
#     with st.sidebar:
#         st.header("‚öôÔ∏è GeoGIS Pro")
        
#         # --- Config Management ---
#         with st.expander("üíæ Config Manager", expanded=False):
#             ex_data = json.dumps({
#                 "markers": st.session_state.markers,
#                 "settings": {k: st.session_state[k] for k in SESSION_KEYS_TO_SAVE if k in st.session_state}
#             }, indent=2)
#             st.download_button("Export Config", ex_data, "config.json", "application/json")
            
#             up_file = st.file_uploader("Import Config", type=["json"])
#             if up_file and st.button("Load Config"):
#                 try:
#                     d = json.load(up_file)
#                     st.session_state.markers = d.get("markers", st.session_state.markers)
#                     for k, v in d.get("settings", {}).items():
#                         if k in SESSION_KEYS_TO_SAVE: st.session_state[k] = v
#                     clear_results()
#                     st.toast("Config Loaded!", icon="‚úÖ")
#                     st.rerun()
#                 except Exception as e: st.error(f"Error: {e}")

#         # --- Inputs ---
#         col1, col2 = st.columns([0.7, 0.3])
#         coords = col1.text_input("Lat, Lon", placeholder="20.21, 100.40", label_visibility="collapsed")
#         if col2.button("Add") and coords:
#             try:
#                 lat, lng = map(float, coords.strip().split(','))
#                 st.session_state.markers.append({'lat': lat, 'lng': lng, 'active': True})
#                 clear_results(['isochrone', 'intersection'])
#                 st.rerun()
#             except: st.error("Invalid Format")

#         # --- Markers List ---
#         active_markers = []
#         if st.session_state.markers:
#             st.markdown("---")
#             for i, m in enumerate(st.session_state.markers):
#                 c1, c2, c3 = st.columns([0.15, 0.70, 0.15])
#                 active = c1.checkbox(" ", value=m.get('active', True), key=f"act_{i}", label_visibility="collapsed")
                
#                 if active != m.get('active', True):
#                     m['active'] = active
#                     clear_results(['isochrone', 'intersection'])
#                     st.rerun()
                
#                 if active: active_markers.append((i, m))
                
#                 style = f"color:{APP_CONFIG['VISUAL']['MARKER_COLORS'][i % 8]}; font-weight:bold;" if active else "color:gray;"
#                 c2.markdown(f"<span style='{style}'>Point {i+1}</span> <span style='font-size:0.8em'>({m['lat']:.3f}, {m['lng']:.3f})</span>", unsafe_allow_html=True)
                
#                 if c3.button("√ó", key=f"del_{i}"):
#                     st.session_state.markers.pop(i)
#                     clear_results(['isochrone', 'intersection'])
#                     st.rerun()

#         # --- Actions ---
#         st.markdown("---")
#         if st.button("üß© Calculate Isochrones", type="primary", use_container_width=True):
#             run_isochrone_calc(active_markers)

#         with st.expander("üï∏Ô∏è Network Analysis", expanded=True):
#             has_iso = st.session_state.isochrone_data is not None
#             st.button("üöÄ Analyze Roads", disabled=not has_iso, use_container_width=True, on_click=run_network_calc)
            
#             if st.session_state.network_data:
#                 stats = st.session_state.network_data.get('stats', {})
#                 st.success(f"Analysed {stats.get('nodes_count', 0)} nodes")
#                 if stats.get('approx'): st.caption("‚ö° Fast Mode (Approximation) Active")
            
#             st.checkbox("Show Roads (Flow)", key="show_betweenness")
#             st.checkbox("Show Hubs (Integration)", key="show_closeness")

#         # --- Map Settings ---
#         with st.expander("üó∫Ô∏è Map Layers"):
#             st.write("Style & Overlays")
#             st.selectbox("Style", list(APP_CONFIG['VISUAL']['MAP_STYLES'].keys()), key="map_style_name")
#             st.toggle("Traffic", key="show_traffic")
#             st.toggle("Population", key="show_population")
#             st.toggle("City Plan", key="show_cityplan")
#             if st.session_state.show_cityplan:
#                 st.slider("Opacity", 0.0, 1.0, key="cityplan_opacity")
            
#             st.write("Parameters")
#             st.selectbox("Travel Mode", list(APP_CONFIG['VISUAL']['TRAVEL_MODES'].keys()), key="travel_mode")
#             st.multiselect("Minutes", [5, 10, 15, 20, 30, 45, 60], key="time_intervals")
#             st.text_input("API Key", key="api_key", type="password")

#     return active_markers

# def run_isochrone_calc(active_markers):
#     if not st.session_state.api_key: return st.toast("‚ö†Ô∏è Missing API Key")
#     if not active_markers: return st.toast("‚ö†Ô∏è No active markers")
    
#     with st.spinner("Calculating Coverage..."):
#         features = []
#         ranges = ",".join(str(t*60) for t in sorted(st.session_state.time_intervals))
        
#         for act_idx, (orig_idx, m) in enumerate(active_markers):
#             feats, err = fetch_api_data_with_error(
#                 st.session_state.api_key, st.session_state.travel_mode, 
#                 ranges, m['lat'], m['lng']
#             )
#             if feats:
#                 for f in feats:
#                     f['properties'].update({
#                         'travel_time_minutes': f['properties'].get('value', 0)/60,
#                         'original_index': orig_idx,
#                         'active_index': act_idx
#                     })
#                     features.append(f)
#             else:
#                 st.toast(f"Point {orig_idx+1}: {err}", icon="‚ö†Ô∏è")
        
#         if features:
#             st.session_state.isochrone_data = {"type": "FeatureCollection", "features": features}
#             cbd = calculate_intersection(features, len(active_markers))
#             st.session_state.intersection_data = {"type": "FeatureCollection", "features": [{"type": "Feature", "geometry": cbd, "properties": {"type": "cbd"}}]} if cbd else None
#             st.toast("Isochrone Calculation Complete!", icon="‚úÖ")
#         else:
#             st.error("Calculation failed for all points.")

# def run_network_calc():
#     if not st.session_state.isochrone_data: return
    
#     status = st.status("üèóÔ∏è Analyzing Network Structure...", expanded=True)
#     try:
#         status.write("Unioning geometries...")
#         feats_json = json.dumps(st.session_state.isochrone_data.get('features', []))
#         poly_wkt = unary_union([shape(f['geometry']) for f in st.session_state.isochrone_data['features']]).wkt
        
#         status.write("Fetching OSM Graph & Calculating Centrality...")
#         result = _compute_centrality_optimized(poly_wkt, 'drive')
        
#         if "error" in result:
#             status.update(label="Analysis Failed", state="error")
#             st.error(result['error'])
#         else:
#             st.session_state.network_data = result
#             status.update(label="Analysis Complete!", state="complete")
            
#     except Exception as e:
#         status.update(label="Error", state="error")
#         st.error(f"System Error: {e}")

# def render_map():
#     conf = APP_CONFIG['VISUAL']['MAP_STYLES'][st.session_state.map_style_name]
#     center = [st.session_state.markers[-1]['lat'], st.session_state.markers[-1]['lng']] if st.session_state.markers else [APP_CONFIG['DEFAULT']['LAT'], APP_CONFIG['DEFAULT']['LON']]
    
#     m = folium.Map(location=center, zoom_start=14, tiles=conf["tiles"], attr=conf["attr"])
    
#     # Layers
#     if st.session_state.show_traffic:
#         folium.TileLayer("https://mt1.google.com/vt?lyrs=h,traffic&x={x}&y={y}&z={z}", attr="Google Traffic", name="Traffic").add_to(m)
        
#     net = st.session_state.network_data
#     if net and 'error' not in net:
#         if st.session_state.show_betweenness and net.get("edges"):
#             folium.GeoJson(
#                 net["edges"], name="Flow",
#                 style_function=lambda x: {'color': x['properties']['color'], 'weight': x['properties']['stroke_weight'], 'opacity': 0.8},
#                 tooltip=folium.GeoJsonTooltip(['betweenness'])
#             ).add_to(m)
#         if st.session_state.show_closeness and net.get("nodes"):
#             folium.GeoJson(
#                 net["nodes"], name="Hubs",
#                 marker=folium.CircleMarker(),
#                 style_function=lambda x: {'fillColor': x['properties']['color'], 'color': 'black', 'radius': x['properties']['radius'], 'fillOpacity': 0.9}
#             ).add_to(m)

#     if st.session_state.isochrone_data:
#         folium.GeoJson(
#             st.session_state.isochrone_data,
#             style_function=lambda x: {
#                 'fillColor': get_fill_color(x['properties']['travel_time_minutes'], st.session_state.colors),
#                 'color': get_border_color(x['properties']['original_index']),
#                 'weight': 1, 'fillOpacity': 0.2
#             }
#         ).add_to(m)
        
#     if st.session_state.intersection_data:
#         folium.GeoJson(
#             st.session_state.intersection_data,
#             style_function=lambda x: {'fillColor': '#FFD700', 'color': '#FF8C00', 'weight': 3, 'fillOpacity': 0.6, 'dashArray': '5, 5'}
#         ).add_to(m)

#     # WMS
#     if st.session_state.show_population:
#         folium.WmsTileLayer(url=LONGDO_WMS_URL, layers='thailand_population', fmt='image/png', transparent=True, attr='Longdo').add_to(m)
#     if st.session_state.show_cityplan:
#         folium.WmsTileLayer(url=LONGDO_WMS_URL, layers='cityplan_dpt', fmt='image/png', transparent=True, attr='Longdo', opacity=st.session_state.cityplan_opacity).add_to(m)

#     # Markers
#     for i, marker in enumerate(st.session_state.markers):
#         active = marker.get('active', True)
#         color = APP_CONFIG['VISUAL']['MARKER_COLORS'][i % 8] if active else "gray"
#         folium.Marker(
#             [marker['lat'], marker['lng']], 
#             popup=f"Point {i+1}",
#             icon=folium.Icon(color=color, icon="map-marker" if active else "ban", prefix='fa')
#         ).add_to(m)

#     return st_folium(m, height=700, use_container_width=True, key="map_widget")

# def main():
#     st.set_page_config(**PAGE_CONFIG)
#     st.markdown("""<style>.block-container { padding-top: 1rem; } </style>""", unsafe_allow_html=True)
    
#     init_session_state()
#     active_markers = render_sidebar()
#     map_data = render_map()
    
#     if map_data and map_data.get('last_clicked'):
#         clk = map_data['last_clicked']
#         if should_add_marker(clk['lat'], clk['lng']):
#             st.session_state.markers.append({'lat': clk['lat'], 'lng': clk['lng'], 'active': True})
#             st.session_state.last_processed_click = {'timestamp': time.time(), 'lat': clk['lat'], 'lon': clk['lng']}
#             clear_results(['isochrone', 'intersection'])
#             st.rerun()

# if __name__ == "__main__":
#     main()
